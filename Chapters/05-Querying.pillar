!! Moose Query

Moose-Query is a domain-specific language (DSL) to build navigations and scoped queries for entities in Moose. Its authors are Anne Etien and Jean-Christophe Bach, joined later by Vincent Blondeau and Cyril Ferlicot-Delbecque. It is the successor of Moose-Chef. It is designed to simplify and standardize the way to query Moose models.

This chapter presents MooseQuery from three perspectives: user, developer (extender of Moose-Query) and API.

!!! User perspective

+A simple model.>file://figures/query-mse-graph.png|width=65|label=query-mse-graph+

An application model in Moose is composed of two concepts as shown in Figure *@query-mse-graph*:

- ""Imbrication of entities."" Defines which entity contains which entities. For example, it defines that classes are contained in a package and that methods are contained in a class. In Figure *@query-mse-graph*, relations ''parentPackage'', ''container'', and ''parentType'' express such a concept. This concept allows one to represent the containment tree of a model.

- ""Associations between entities."" Specify how the entities interact with each other. For example, an inheritance is an association between a subclass and its superclass. Another example is that a reference is an association between a behavioural entity and a type. In Figure *@query-mse-graph*, the object '':Inheritance'' with the ''superclass'' and ''subclass'' relations represents such concept.

MooseQuery allows exploring a model via those two concepts. You can:
- Explore the containment tree
- Gather associations
- Manipulate the gathered associations
- Change the scope of entities (move from classes to their parent package or their children methods)

In this chapter, we detail the use of the DSL. At the end, you will be able to query your Moose model, for example, to:

- Get the children of an entity (Exploration of the containment tree)
- Get all the associations contained in a class (Gathering of associations)
- Get all the entities who depend on a specific entity (Manipulation of the gathered associations)
- Get all the methods contained in a package in a Java model, including those in inner/anonymous classes (Change of scope)

!!! Containment tree query API 

Navigate the containment tree is the easiest way to query a model. It is possible with the association relationsl. To do so, there is a really simple API on entities:

| ""Selector"" | ""Description""|
| ==children== | Return the direct children of the entity |
| ==parents== | Return the direct parents of the entity |
| ==allChildren== | Return the children of the entity and their children recursively |
| ==allParents== | Return the parents of the entity and their parents recursively |

+A simple containment model.>file://figures/containmentTreeUser.png|width=65|label=query2+


!!! Containment query examples
For example using the model shown in Figure *@query2* we can express the following queries with their results

[[[
package1 children
>>> { package2 . class1 }
]]]

[[[
class3 children
>>> { attribute1 . attribute2 }
]]]

[[[
package1 allChildren
>>> { package2 . class1 . class2 . class3 . attribut1 . attribut2 }
]]]

[[[
class3 allChildren
>>>{ attribut1 . attribut2 }
]]]

[[[
package1 parents
>>> { }
]]]

[[[
class3 parents
>>> { package2 }
]]]
[[[
class4 parents 
>>> { package3 . namespace1 }
]]]
[[[
class3 allParents
>>> { package2 . package1 }
]]]
[[[
attribute1 allParents
>>>{ class3 . package2 . package1 }
]]]


!!! Navigation queries

To navigate links between entities, MooseQuery provides a generic API to gather entities' associations. Those associations represent a different kind of links such as ''References'', ''Inheritance'', ''Accesses'', or ''Invocations''.

These queries are configured with three parameters:
- The direction of the association (incoming or outgoing). An incoming association represents a relation where the studied entity (receiver of the query) is the target of the relation. An outgoing association represents a relation where the studied entity is the source of the relation.
- The association(s) that is queried.
- In addition, a query can be either local or not. A local query searches only in the associations of the receiver while a non-local query also gathers the entity children's associations.


!!! Navigation query API 

The main methods to perform navigation queries are:


- ==query: direction with: associationClass == This method takes as first parameter a symbol (==#out== or ==#in==) to define the direction of the query and as second parameter an association class to query. Return: All the instances of this association class where the receiver or its children are the source/target depending on the direction.|
- ==queryAll: direction==  This method takes as parameter a symbol (==#out== or ==#in==) to define the direction of the query. It takes into account all kind of associations. ''Return:'' All the association's instances where the receiver or its children are the source/target depending on the direction.
- ==queryLocal:direction with: associationClass==  This method is equivalent to ==query:with:== but takes into account only the studied entity without its children. It takes as first parameter a symbol (==#out== or ==#in==) to define the direction of the query and as second parameter an association class to query. ''Return:'' All the instances of this association class where the receiver only is the source/target depending on the symbol.
- ==queryAllLocal: direction== This method is equivalent to ==queryAll:== but takes into account only the studied entity without its children. It takes as parameter a symbol (==#out== or ==#in==) to define the direction of the query. It takes into account all kind of associations. ''Return:'' All the association's instances where the receiver only is the source/target depending on the symbol.


+Example of a small model with associations.>file://figures/query-navigationUser.png|width=75|label=query3+

!!! Navigation query examples
Using the model shown in Figure *@query3* we can express the following queries with their results.


[[[
class1 query: #in with: FAMIXInheritance. 
>>> { inheritance1 }
]]]
We get the inheritance1 object whose target is class1.


[[[
class1 query: #out with: FAMIXInheritance. 
>>> { }
]]]
Since class1 is not the source of any inheritance relation, the query result is empty. 


Now a more subtle point showing the interplay between containment and navigation. 
[[[
class1 query: #out with: FAMIXAccess. 
>>> { access1 }. 
]]]
This query returns access1 because even if the class does not explicitly refers to attribute1 via a direct access. One if its method is actually accessing attributes hence the query returns access1. It considers conceptually that the variable (target) link is an outlink of class1. 
Since method1 is contained (its parentType is class1) in class1 accesses Attribute1 via Access1. The access is not directly done via class1, but via its children.

[[[
class1 queryLocal: #out with: FAMIXAccess. 
>>> { }. 
]]]
Empty result since  class1 is not directly the source of access1.

[[[
class1 queryLocal: #in with: FAMIXInheritance. 
>>> { inheritance1 }
]]]


[[[
class1 queryAll: #in. 
>>> { inheritance1 . reference1 }
]]]

What is important to see with the example above is that only the navigation relationships are taken into account. The containment hierarchy is not reported but used when the children of an entity are taken into account - as this is the case for non local queries. 

The next query is simpler to understand. 
[[[
class1 queryAllLocal: #in. 
>>> { inheritance1 . reference1 }
]]]



Here again while class1 does not explicitly act as a source of a relation, since one of its childen (method1) does
the query takes it into account and fusion the method as it was the class. Therefore it returns the relationship access1. 

[[[
class1 queryAll: #out. 
>>> { access1 }
]]]

In a local set up, class1 does not act as a source of any kind so the query result is empty. 
[[[
class1 queryAllLocal: #out. 
>>> { }
]]]

!!! Types of association
Now we can ask ourselves how to know which entity can be the source or target of which type of association. For this, it exists an API based on the meta-model of your application. These methods have to be sent to an entity class e.g. ==FAMIXClass incomingAssociationTypes==. 

|""Selector""|Description|
| ==aClass outgoingAssociationTypes== | Return all the possible outgoing association types for this entity. This does not include the outgoing association types of its possible children.
| ==aClass incomingAssociationTypes== | Return all the possible incoming association types for this entity. This does not include the incoming association types of its possible children.
| ==aClass allOutgoingAssociationTypes== | Return all the possible outgoing association types for this entity, including the outgoing association types of its possible children.
| ==aClass allIncomingAssociationTypes== | Return all the possible incoming association types for this entity, including the incoming association types of its possible children.


!!!! Association type query examples

[[[
FAMIXType outgoingAssociationTypes. 
>>> { FAMIXInheritance }
]]]

[[[
FAMIXType incomingAssociationTypes. 
>>> { FAMIXInheritance . FAMIXTraitUsage . FAMIXReference }
]]]

[[[
FAMIXType allOutgoingAssociationTypes. 
>>> { FAMIXAccess . FAMIXInheritance . FAMIXInvocation . FAMIXReference }
]]]

[[[
FAMIXType allIncomingAssociationTypes. 
>>> { FAMIXAccess . FAMIXInheritance . FAMIXInvocation . FAMIXReference . FAMIXTraitUsage }
]]]

!!! Query result handling

A navigation query returns a result as a MooseQueryResult. There are three types of query results:

- MooseIncomingQueryResult manages the result of a query on incoming associations.
- MooseOutgoingQueryResult manages the result of a query on outgoing associations.
- MooseObjectQueryResult is special kind of query result that can be obtained via the two others ones and includes the opposites of the receiver associations. (For example if you query the outgoing accesses of a class, the opposites of the class associations will be the accessed attributes) SD:???

These query results classes are special collections with some new features.

One of the most useful ones is the ==opposites== message that can be sent to MooseIncomingQueryResult and MooseOutgoingQueryResult. It returns a MooseObjectQueryResult containing all the opposites entities of the query result compared to the receiver of the query.

!!!! Example 
[[[
class1 queryAll: #in. 
>>> { inheritance1 . reference1 }
]]]

[[[
(class1 queryAll: #in) opposites. 
>>> { class2 . method2 }
]]]

Indeed, when we query a model, it is often not the associations that we want as result but the source/target entities of these associations. For example, if we want the instance variables accessed by a given method, #query:with: will returns the accesses whereas sending the message #opposites on the result returns the variables themselves.
