!! Moose Query

Moose-Query is a domain-specific language (DSL) to build navigations and scoped queries for entities in Moose. Its authors are Anne Etien and Jean-Christophe Bach, joined later by Vincent Blondeau and Cyril Ferlicot-Delbecque. It is the successor of Moose-Chef. It is designed to simplify and standardize the way to query Moose models.

This chapter presents MooseQuery from three perspectives: user, developer (extender of Moose-Query) and API.

!!! User perspective

+A simple model.>file://figures/query-mse-graph.png|width=65|label=query-mse-graph+

An application model in Moose is composed of two concepts as shown in Figure *@query-mse-graph*:

- ""Imbrication of entities."" Defines which entity contains which entities. For example, it defines that classes are contained in a package and that methods are contained in a class. In Figure *@query-mse-graph*, relations ''parentPackage'', ''container'', and ''parentType'' express such a concept. This concept allows one to represent the containment tree of a model.

- ""Associations between entities."" Specify how the entities interact with each other. For example, an inheritance is an association between a subclass and its superclass. Another example is that a reference is an association between a behavioural entity and a type. In Figure *@query-mse-graph*, the object '':Inheritance'' with the ''superclass'' and ''subclass'' relations represents such concept.

MooseQuery allows exploring a model via those two concepts. You can:
- Explore the containment tree
- Gather associations
- Manipulate the gathered associations
- Change the scope of entities (move from classes to their parent package or their children methods)

In this chapter, we detail the use of the DSL. At the end, you will be able to query your Moose model, for example, to:

- Get the children of an entity (Exploration of the containment tree)
- Get all the associations contained in a class (Gathering of associations)
- Get all the entities who depend on a specific entity (Manipulation of the gathered associations)
- Get all the methods contained in a package in a Java model, including those in inner/anonymous classes (Change of scope)

!!! Containment tree query API 

Navigate the containment tree is the easiest way to query a model. It is possible with the association relationsl. To do so, there is a really simple API on entities:

| ""Selector"" | ""Description""|
| ==children== | Direct children of the entity |
| ==parents== | Direct parents of the entity |
| ==allChildren== | Children of the entity and their children recursively |
| ==allParents== | Parents of the entity and their parents recursively |

+A simple model.>file://figures/containmentTreeUser.png|width=65|label=query2+


!!! Containment query examples
For example using the model shown in Figure @*query2@ we can express the following queries with their results

[[[
package1 children
>>> { package2 . class1 }
]]]

[[[
class3 children
>>> { attribute1 . attribute2 }
]]]

[[[
package1 allChildren
>>> { package2 . class1 . class2 . class3 . attribute1 . attribute2 }
]]]

[[[
class3 allChildren
>>>{ attribute1 . attribute2 }
]]]

[[[
package1 parents
>>> { }
]]]

[[[
class3 parents
>>> { package2 }
]]]
[[[
class4 parents 
>>> { package3 . namespace1 }
]]]
[[[
class3 allParents
>>> { package2 . package1 }
]]]
[[[
attribute1 allParents
>>>{ class3 . package2 . package1 }
]]]


!!! Navigation queries

To navigate links between entities, MooseQuery provides a generic API to gather entities' associations. Those associations represent a different kind of links such as ''References'', ''Inheritance'', ''Accesses'', or ''Invocations''.

These queries are configured with three parameters:
- The direction of the association (incoming or outgoing). An incoming association represents a relation where the studied entity (receiver of the query) is the target of the relation. An outgoing association represents a relation where the studied entity is the source of the relation.
- The association(s) that is queried.
- In addition, a query can be either local or not. A local query searches only in the associations of the receiver while a non-local query also gathers the entity children's associations.


!!! Navigation query API 

The main methods to perform navigation queries are:


- ==query:with:== This method takes as first parameter a symbol (#out or #in) to define the direction of the query and as second parameter an association class to query. Return: All the instances of this association class where the receiver or its children are the source/target depending on the symbol.|
- queryAll:  This method takes as parameter a symbol (#out or #in) to define the direction of the query. It takes into account all kind of associations. Return: All the association's instances where the receiver or its children are the source/target depending on the symbol.
- ==queryLocal:with:==  This method is equivalent to #query:with: but takes into account only the studied entity without its children. It takes as first parameter a symbol (#out or #in) to define the direction of the query and as second parameter an association class to query. Return: All the instances of this association class where the receiver only is the source/target depending on the symbol.
- ==queryAllLocal:== This method is equivalent to #queryAll: but takes into account only the studied entity without its children. It takes as parameter a symbol (#out or #in) to define the direction of the query. It takes into account all kind of associations. Return: All the association's instances where the receiver only is the source/target depending on the symbol.


+Example of a small model with associations.>file://figures/query-navigationUser.png|width=65|label=query3+

!!! Navigation query examples
For example using the model shown in Figure @*query3@ we can express the following queries with their results

[[[
class1 query: #in with: FAMIXInheritance. 
>>> { inheritance1 }
]]]

[[[
class1 query: #out with: FAMIXInheritance. 
>>> { }
]]]

[[[
class1 query: #out with: FAMIXAccess. 
>>> { access1 }. 
]]]
Method1 is contained in Class1 accesses Attribute1 via Access1. The access is not directly done via Class1, but via its children.

[[[
class1 queryLocal: #in with: FAMIXInheritance. 
>>> { inheritance1 }
]]]

[[[
class1 queryLocal: #out with: FAMIXAccess. 
>>> { }. 
]]]
No result because Class1 is not directly the source of Access1.

[[[
class1 queryAll: #in. 
>>> { inheritance1 . reference1 }
]]]
[[[
class1 queryAll: #out. 
>>> { access1 }
]]]

[[[
class1 queryAllLocal: #in. 
>>> { inheritance1 . reference1 }
]]]

[[[
class1 queryAllLocal: #out. 
>>> { }
]]]







